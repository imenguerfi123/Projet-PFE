<center><h1 style="color: #ff0000">GNU compilation chain</h1></center>

<h2>Definition</h2>
The GNU compilation chain used in the free software world includes the following elements:

**binutils:** a collection of utilities used for processing binary files; this package contains in particular 
the assembler which transforms the pseudo-code generated by the compilation into instructions understood by 
the target processor, and the linker to link the libraries used by a program.

**gcc:** the C and C ++ compilers of the collection

**glibc:** system C library used for kernel calls and low-level-process processing

**The Kernel Headers:** required by the glibc library (linux-headers in the case of the Linux kernel)

**gdb:** optional component for debugging an already compiled binary string

<img src="https://preshing.com/images/cross-gcc-sandwich.png">

<h2>Installation of a compilation chain</h2>

The components of the chain in GNU / Linux environment use the construction mechanisms of the GNU system. 
The configure script specifies the host and target architectures (host and target parameters). 
Distributions can provide an abstraction layer to simplify management (ebuild for Gentoo, Cookutils for SliTaz2),
or tools like Crosstool, Buildroot for embedded systems.

<img src="https://preshing.com/images/gcc-cross-compiler.png">

<h2>Native compilation chain</h2>

We speak of native compilation when the chain is compiled on a machine that is **both host and target**. 
The elements of the chain are installed in packages for so-called binary distributions (for example, 
deb for Debian, rpms for Red Hat), or are compiled from sources for source distributions. 
The compilation chain generates executables on the same hardware architecture for which it was compiled.

<h2>Cross compilation chain</h2>

A cross compilation chain is a chain compiled to operate on the processor architecture of the host machine,
but which will compile software for a different target architecture. In this case, it is necessary to compile
the string from the source code.

<h2>Compilation</h2>

**A compiler:** is a computer program that transforms computer code written in one programming language (the source language) 
into another programming language (the target language). In general, the compilation is the generation of an executable object 
or an assembly file from a high level language written program. 

<img src="https://encrypted-tbn0.gstatic.com/images?q=tbn%3AANd9GcSBwg3qL88DNV14ezBqQITCg8APcDzSvA0WiBeYig6MQj27KLrv" width=500>

**Compile:** is the action of transforming the source code of a program into an adapted and personalized binary image which
will be executed within your GNU-Linux system. A file often called **“makefile”** acts as a super recipe, it is used by 
the **“make”** program which will **bring together and link the different elements necessary for the final realization**
(the program ready to be used) from the source code ". To do this “make” will use a compiler which on a GNU-Linux system 
is generally **“gcc”**.

<h2> kernel modules</h2>
Kernel modules are pieces of code that can be loaded and unloaded into the kernel upon demand. 
They extend the functionality of the kernel without the need to reboot the system.
Custom codes can be added to Linux kernels via two methods.

  - The basic way is to add the code to the kernel source tree and recompile the kernel.
  - A more efficient way is to do this is by adding code to the kernel while it is running. This process
     is called loading the module, where module refers to the code that we want to add to the kernel.
<img src="https://images.slideplayer.com/16/5263977/slides/slide_3.jpg">

Since we are loading these codes at **runtime** and they are not part of the official Linux kernel, 
these are called **loadable kernel module(LKM)**, which is different from the **“base kernel”**. 

<h2>Utilities to Manipulate Kernel Modules</h2>
<br>
<img src="https://tournasdimitrios1.files.wordpress.com/2010/11/15-11-2010-managing-moduls-on-the-linux-kernel.png?w=400">
<br>

 - **insmod :** Insert Module into Kernel

 - **lsmod :** List Modules that Loaded Already

 - **modinfo :** Display Module Info

 - **rmmod :** Remove Module from Kernel

 - **modprobe :** Add or Remove modules from the kernel
 
 - **depmod :**(Dependency Modules) generate a list of dependency description of kernel modules and its associated map files.

Base kernel is located in **/boot directory** and is always loaded when we boot our machine whereas LKMs are loaded after
the base kernel is already loaded. Nonetheless, these LKM are very much part of our kernel and they communicate with base kernel
to complete their functions.

The kernel modules will have a **.ko extension**. On a normal linux system.

The kernel modules will reside inside **/lib/modules/kernel_version/kernel/ directory**.


<h2>How to Write Your Own Linux Kernel Module</h2>

   **1 . Installing the linux headers**

You need to install the linux-headers.Depending on your distro, use apt-get or yum.

       apt-get install build-essential linux-headers-$(uname -r)

>The header files define an interface: they specify how the functions in the source file are defined.

   **2 . create Module Source Code**

create the **file.c** module in C programming language.

>Kernel modules must have at least two functions: 
>
 >-  A "start" (initialization) function called init_module() which is called when the module is insmoded into the kernel
 >- an "end" (cleanup) function called cleanup_module() which is called just before it is rmmoded.


 >Warning: All kernel modules will operate on kernel space, a highly privileged mode. So be careful with what you write in a kernel module.
 
  **3 . Create Makefile to Compile Kernel Module**

The makefile can be used to compile the above basic kernel module.
Use the make command to compile kernel module 
The above will create **.ko file**, which is our sample Kernel module.

>From a technical point of view the first line is necessary to create objects after program compilation, 
>the "all" and "clean" targets were added for pure convenience. 


 **4 . Insert or Remove the Sample Kernel Module**

Now that we have our **.ko file**, we can insert this module to the kernel by using **insmod** command

<h2>Linking module to Kernel</h2><br>

<img src="https://www.xml.com/ldd/chapter/book/figs/ldr2_1201.gif" width=500>

When a module is inserted into the kernel, the module-init macro will be invoked, which will call the function **module_init**. 

Similarly, when the module is removed with **rmmod**, module-exit macro will be invoked, which will call the  **module_exit**. 

There is also an __initdata which works similarly to __init but for init variables rather than functions. 

Using **dmesg** command, we can see the output from the sample Kernel module.

<h2>Sources</h2>
</br>

[ Linux Kernel Module Programming]( https://www.geeksforgeeks.org/linux-kernel-module-programming-hello-world-program/)



[ How to Write Your Own Linux Kernel Module with a Simple Example]( https://www.thegeekstuff.com/2013/07/write-linux-kernel-module/)













